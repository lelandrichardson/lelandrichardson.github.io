{"data":{"site":{"siteMetadata":{"title":"Intelligible Babble","author":"Leland Richardson"}},"markdownRemark":{"id":"82f11951-da8a-57d5-8d42-e758d70e5fe6","excerpt":"For some reason or another, it seems to me that SQL has always taken a back seat in the language economy. I have used SQL for years, and…","html":"<p>For some reason or another, it seems to me that SQL has always taken a back seat in the language economy. I have used SQL for years, and very little has changed.</p>\n<p>After working on a couple of relatively large projects which use SQL quite a bit, I have slipped into a bit of a love-hate relationship with SQL.</p>\n<p>SQL has lot’s of beautiful features. SQL is already a fairly high-order language; a tremendous amount of implementation detail is left invisible to the programmer. In terms of spewing data out of a data store, it can be impressively efficient.</p>\n<p>But somehow it just still isn’t quite <em>there</em>. Right?</p>\n<p>Most developers I know seem to avoid SQL like the plague… and that’s too bad.</p>\n<p>One day I started thinking about some of the specific hardships I’ve had with maintaining a large SQL codebase, and something dawned on me…</p>\n<p>Why hasn’t anyone created more convenient languages that transpile into SQL?</p>\n<p>There is CoffeeScript, Dart, Typescript, etc for JavaScript.<br>\nThere is LESS and SCSS for CSS.</p>\n<p><strong>Why not something for SQL?</strong></p>\n<p>So I played the devil’s advocate and said: “What if SQL was a compile target?”</p>\n<p>In doing so, I found myself wanting a language that:</p>\n<ul>\n<li><strong>Strict superset of SQL.</strong> This is important because it promotes a clean transition. One can move migrate their SQL codebase incrementally since all valid SQL is also valid in this language.</li>\n<li><strong>Promotes good and efficient SQL practices</strong></li>\n<li><strong>Promotes keeping SQL code DRY</strong></li>\n<li><strong>Transpiles into easily readable SQL</strong></li>\n</ul>\n<p>For now I will call “BQL” for “A Better Query Language”. I have taken a stab at outlining below a rough specification for what I think would be some positive features to add, while adhering to the constraints above.</p>\n<p>To summarize what I see as “benificial” to a language such as this, I would put as the following:</p>\n<h2>Key Language Benefits</h2>\n<ul>\n<li>notion of “projections” to keep SQL efficient, and keep code DRY</li>\n<li>inner joins are inferred with simplified syntax</li>\n<li>reordered select/from clauses to make autocomplete context more helpful</li>\n<li>queries can be stored syntactically and referenced in other statements to help readability, logical separation, and DRYness</li>\n<li>strict superset, so all SQL is already valid</li>\n<li>syntactic niceties with variable declaration / boolean logic / functions / etc.</li>\n</ul>\n<h2>Language Specification</h2>\n<hr>\n<h3>The <code class=\"language-text\">select</code> clause can be anywhere in a statement</h3>\n<p>In TSQL, the <code class=\"language-text\">select</code> clause of a select statement is done first, which makes it logically difficult to provide meaningful autocomplete suggestions for field names currently available in the context, since that is defined afterwards in the <code class=\"language-text\">from</code> and <code class=\"language-text\">join</code> clauses.</p>\n<p>In BQL, the <code class=\"language-text\">select</code> is valid at both the beginning and the end of the query.</p>\n<p>For example, the following BQL statements are equivalent:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> student\n<span class=\"token keyword\">where</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'enrolled'</span>\n<span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> grade\n\n\n<span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> grade\n<span class=\"token keyword\">from</span> student\n<span class=\"token keyword\">where</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'enrolled'</span></code></pre></div>\n<p>both of which will compile into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    name<span class=\"token punctuation\">,</span>\n    grade\n<span class=\"token keyword\">FROM</span> student\n<span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'enrolled'</span></code></pre></div>\n<h3>With the presence of foreign keys, join conditions are implied</h3>\n<p>Provided there is a single foreign key relationship defined unambiguously between two tables, the foreign key relationship is chosen implicitly as the default join condition.</p>\n<p>For instance, let’s say we have the following simplified tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> post <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">comment</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    postId <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key to post.id</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The following BQL statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> post\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">comment</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span></code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> post p\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">comment</span> c\n<span class=\"token keyword\">ON</span> c<span class=\"token punctuation\">.</span>postId <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>id</code></pre></div>\n<p>When multiple tables are joined in a single statement, the table with which you want to join may become ambiguous, and an optional <code class=\"language-text\">with</code> clause can be added to the join:</p>\n<p>For instance, we may have the following tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> post <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    authorId <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">comment</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    postId <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key to post.id</span>\n    authorId <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key to user.id</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>then the following BQL statement</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> post\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">user</span> u1 <span class=\"token keyword\">with</span> post\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">comment</span>\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">user</span> u2 <span class=\"token keyword\">with</span> <span class=\"token keyword\">comment</span>\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span></code></pre></div>\n<p>compiles to:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> post p\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">user</span> u1\n<span class=\"token keyword\">ON</span> post<span class=\"token punctuation\">.</span>authorId <span class=\"token operator\">=</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">comment</span> c\n<span class=\"token keyword\">ON</span> <span class=\"token keyword\">comment</span><span class=\"token punctuation\">.</span>postId <span class=\"token operator\">=</span> post<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">user</span> u2\n<span class=\"token keyword\">ON</span> <span class=\"token keyword\">comment</span><span class=\"token punctuation\">.</span>authorId <span class=\"token operator\">=</span> <span class=\"token keyword\">user</span><span class=\"token punctuation\">.</span>id</code></pre></div>\n<p>Furthermore, in some cases there are multiple foreign keys from one table to a single table. In this case, the join condition is ambiguous until you clarify which foreign key relationship you would like to use. As a result, one can use the <code class=\"language-text\">on</code> clause, however, unlike it’s SQL counterpart, only the column in the “foreign” table is needed.</p>\n<p>To demonstrate, provided we have the following tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">DECLARE</span> <span class=\"token keyword\">TABLE</span> message <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- primary key</span>\n    senderId <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key with user.id</span>\n    recipientid <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- foreign key with user.id</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Thus, the following BQL query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> message m\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">user</span> s <span class=\"token keyword\">on</span> senderId\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token keyword\">user</span> r <span class=\"token keyword\">on</span> recipientId\n<span class=\"token keyword\">select</span> <span class=\"token operator\">*</span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> message m\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">user</span> s <span class=\"token keyword\">ON</span> m<span class=\"token punctuation\">.</span>senderId <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> <span class=\"token keyword\">user</span> r <span class=\"token keyword\">ON</span> m<span class=\"token punctuation\">.</span>recipientId <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span>id</code></pre></div>\n<h3>Short-cutting Join Conditions in <code class=\"language-text\">where</code> clauses…</h3>\n<p>Joins are commonly used simply to perform a lookup and return the corresponding rows of one table. Provided there is a unique foreign key relationship between two tables, the lookup can be performed by a simple condition in the where clause like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> <span class=\"token keyword\">user</span>\n<span class=\"token keyword\">where</span> <span class=\"token keyword\">user</span>:country<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Canada'</span>\n<span class=\"token keyword\">select</span> id</code></pre></div>\n<p>which compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> u<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> country c\n<span class=\"token keyword\">ON</span> c<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> u<span class=\"token punctuation\">.</span>country_id\n<span class=\"token keyword\">WHERE</span> c<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Canada'</span></code></pre></div>\n<p>Here the <code class=\"language-text\">{fk table name}:{pk table name}</code> syntax is used to identify the join while making the condition more easily legible.</p>\n<h3>Table Projections</h3>\n<p>Table projections are a construct in BQL which is not present in standard SQL. A table projection is simply a named collection of field names which can be used (and thus re-used) in the select clause of any query.</p>\n<p>For instance, one can define a projection as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">projection <span class=\"token punctuation\">[</span>contact_info<span class=\"token punctuation\">]</span> {\n    firstName<span class=\"token punctuation\">,</span>\n    lastName<span class=\"token punctuation\">,</span>\n    phoneNumber<span class=\"token punctuation\">,</span>\n    email\n}</code></pre></div>\n<p>and thus, the BQL query</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> dbo<span class=\"token punctuation\">.</span>users\n<span class=\"token keyword\">select</span> <span class=\"token operator\">&lt;</span>contact_info<span class=\"token operator\">></span></code></pre></div>\n<p>compiles into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    firstName<span class=\"token punctuation\">,</span>\n    lastName<span class=\"token punctuation\">,</span>\n    phoneNumber<span class=\"token punctuation\">,</span>\n    email\n<span class=\"token keyword\">FROM</span> dbo<span class=\"token punctuation\">.</span>users</code></pre></div>\n<p>Further, I can mix selecting Projections and field names if needed:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> dbo<span class=\"token punctuation\">.</span>users\n<span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>contact_info<span class=\"token operator\">></span></code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    firstname<span class=\"token punctuation\">,</span>\n    lastName<span class=\"token punctuation\">,</span>\n    phoneNumber<span class=\"token punctuation\">,</span>\n    email\n<span class=\"token keyword\">FROM</span> dbo<span class=\"token punctuation\">.</span>users</code></pre></div>\n<p>The projection can be prefixed by the table name or table alias if you are projecting a specific table in a join…</p>\n<p>for instance, provided we have the following projections:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">projection abc { a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c }\n\nprojection def { d<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> f }</code></pre></div>\n<p>this BQL statement</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> tblX x\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> tblY y\n<span class=\"token keyword\">on</span> x<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> y<span class=\"token punctuation\">.</span>xid\n<span class=\"token keyword\">select</span> x<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>abc<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>def<span class=\"token operator\">></span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    x<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>\n    x<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">,</span>\n    x<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">.</span>e<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">.</span>f\n<span class=\"token keyword\">FROM</span> tblX X\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> tblY y\n<span class=\"token keyword\">ON</span> x<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> y<span class=\"token punctuation\">.</span>id</code></pre></div>\n<h3>The special <code class=\"language-text\">&lt;$all&gt;</code>, <code class=\"language-text\">&lt;$keys&gt;</code> Projection</h3>\n<p>Every table by default has an “include all” projection. This does not need to be defined anywhere, and is pragmatically equivalent to the ”*” operator in normal SQL, except for the fact that the compiled SQL will have all of the table’s fields enumerated explicitly in the compilation step.</p>\n<p>Given we have the following table definitions:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">table</span> abc <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">-- (primary key)</span>\n    f1 <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>\n    f2 <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    f3 <span class=\"token keyword\">datetime</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">table</span> def <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">int</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span>\n    abcId <span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">-- (foreign key to tbl1.id)</span>\n    f4 <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    f5 <span class=\"token keyword\">datetime</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The following projections are implicitly created for these tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- for table \"abc\"</span>\nprojection $<span class=\"token keyword\">all</span> { id<span class=\"token punctuation\">,</span> f1<span class=\"token punctuation\">,</span> f2<span class=\"token punctuation\">,</span> f3 }\nprojection $<span class=\"token keyword\">keys</span> { id }\n\n<span class=\"token comment\">-- for table \"def\"</span>\nprojection $<span class=\"token keyword\">all</span> { id<span class=\"token punctuation\">,</span> abcId<span class=\"token punctuation\">,</span> f4<span class=\"token punctuation\">,</span> f5 }\nprojection $<span class=\"token keyword\">keys</span> { id<span class=\"token punctuation\">,</span> abcId }</code></pre></div>\n<p>and thus, the following BQL statements:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> abc <span class=\"token keyword\">select</span> <span class=\"token operator\">&lt;</span>$<span class=\"token keyword\">all</span><span class=\"token operator\">></span>\n\n<span class=\"token keyword\">from</span> abc\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> def\n<span class=\"token keyword\">on</span> abc<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> def<span class=\"token punctuation\">.</span>abcId\n<span class=\"token keyword\">select</span> abc<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>$<span class=\"token keyword\">keys</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> def<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>$<span class=\"token keyword\">keys</span><span class=\"token operator\">></span></code></pre></div>\n<p>compile into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    f1<span class=\"token punctuation\">,</span>\n    f2<span class=\"token punctuation\">,</span>\n    f3\n<span class=\"token keyword\">FROM</span> abc\n\n<span class=\"token keyword\">SELECT</span>\n    abc<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n    def<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n    def<span class=\"token punctuation\">.</span>abcId\n<span class=\"token keyword\">FROM</span> abc\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> def\n<span class=\"token keyword\">ON</span> abc<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> def<span class=\"token punctuation\">.</span>abcId</code></pre></div>\n<p>Similar to select lists, you can also specify computed columns as well as field name aliases</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">projection foo {\n    id <span class=\"token keyword\">as</span> userId<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'{{first}} {{last}}'</span> <span class=\"token keyword\">as</span> displayName\n}</code></pre></div>\n<p>where the projection takes:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> users\n<span class=\"token keyword\">select</span> <span class=\"token operator\">&lt;</span>foo<span class=\"token operator\">></span></code></pre></div>\n<p>and compiles it into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id <span class=\"token keyword\">as</span> userId<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">first</span> <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">last</span> <span class=\"token keyword\">as</span> displayName\n<span class=\"token keyword\">FROM</span> users</code></pre></div>\n<p>Projection definitions can also reference other projections:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">projection fullName {\n    <span class=\"token string\">'{{first}} {{last}}'</span> <span class=\"token keyword\">as</span> fullName\n}\n\nprojection <span class=\"token keyword\">user</span> {\n    id<span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">&lt;</span>fullName<span class=\"token operator\">></span>\n}</code></pre></div>\n<p>and thus:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> users\n<span class=\"token keyword\">select</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">user</span><span class=\"token operator\">></span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    email<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">first</span> <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">last</span> <span class=\"token keyword\">as</span> fullName\n<span class=\"token keyword\">FROM</span> users</code></pre></div>\n<p>Notes about projections:</p>\n<ul>\n<li>they can be thought of as ad-hoc interfaces. They can be applied to any table, but will be a SQL compile error if the proper field names are not present on the table</li>\n<li>one can select multiple projections, comma delimited. in this case, common field names between the projections will be repeated… (or should they just be indicated once???)</li>\n<li>if projecting a table alias <code class=\"language-text\">a</code>, it would be <code class=\"language-text\">select a.&lt;contact_info&gt;</code></li>\n<li>if a delimited name is needed, it would be <code class=\"language-text\">select &lt;[projection name]&gt;</code></li>\n<li>the above example uses another feature of BQL discussed below, string interpolation.</li>\n</ul>\n<h3>Boolean values first class citizens</h3>\n<p>BQL has <code class=\"language-text\">true</code> and <code class=\"language-text\">false</code> as new keywords which translate into a SQL <code class=\"language-text\">bit</code> data type.</p>\n<p>For instance, the following BQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token boolean\">true</span></code></pre></div>\n<p>Compiles into the following SQL:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@true</span> <span class=\"token keyword\">BIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SELECT</span> <span class=\"token variable\">@true</span></code></pre></div>\n<p>If any statement contains usage of the boolean values <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code>, it will be transpiled into a local variable reference which is initialized at <code class=\"language-text\">1</code> or <code class=\"language-text\">0</code> accordingly. This prevents some common ambiguities found between the <code class=\"language-text\">BIT</code> value of 1 and the <code class=\"language-text\">INT</code> value of 1.</p>\n<p>Further, many expressions are automatically converted into boolean expressions if evaluated in an <code class=\"language-text\">if</code> structure or a <code class=\"language-text\">where</code> clause.</p>\n<p>Note: more needs to be discussed on first-class suport of booleans in BQL.</p>\n<h3>Setting variables</h3>\n<p>no need for <code class=\"language-text\">SET</code>… ie, the line <code class=\"language-text\">@a = 1</code> => <code class=\"language-text\">SET @a = 1</code></p>\n<h3>Control-flow Logic</h3>\n<p>BQL introduces the usage of curly brackets as natural scope boundaries, similar to (but not equivalent to) SQL’s <code class=\"language-text\">BEGIN ... END</code> syntax.</p>\n<h3>Brackets as scope boundaries</h3>\n<p>instead of <code class=\"language-text\">BEGIN ... END</code> we would have brackets. ie,</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token comment\">/* boolean expression */</span> <span class=\"token punctuation\">)</span> {\n    <span class=\"token comment\">/* expression */</span>\n} <span class=\"token keyword\">else</span> {\n    <span class=\"token operator\">/</span><span class=\"token operator\">*</span> expression\n}</code></pre></div>\n<h3>Variable declaration simplified…</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- implicit type</span>\nvar <span class=\"token variable\">@a</span> <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token variable\">@b</span> <span class=\"token operator\">=</span> <span class=\"token number\">123</span>\n\n<span class=\"token comment\">-- explicit type</span>\n<span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token variable\">@a</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token variable\">@b</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">datetime</span> <span class=\"token variable\">@c</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Instead of:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@a</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span>MAX<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span>\n<span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@b</span> <span class=\"token keyword\">INT</span> <span class=\"token operator\">=</span> <span class=\"token number\">123</span>\n\n<span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@a</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@b</span> <span class=\"token keyword\">INT</span>\n<span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@c</span> <span class=\"token keyword\">DATETIME</span></code></pre></div>\n<h3>Better implicit type coercion…</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">print</span> <span class=\"token string\">'abc'</span> <span class=\"token operator\">+</span> <span class=\"token number\">123</span>  <span class=\"token comment\">// prints 'abc123'</span></code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">PRINT</span> <span class=\"token string\">'abc'</span> <span class=\"token operator\">+</span> CAST<span class=\"token punctuation\">(</span><span class=\"token number\">123</span> <span class=\"token keyword\">AS</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Note: this should be thought about a little more. I like this, but it could actually cause existing (valid) SQL to break where the original intention different.</p>\n<h3>C-style <code class=\"language-text\">for</code> loops</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">&lt;</span> <span class=\"token variable\">@length</span><span class=\"token punctuation\">;</span> <span class=\"token variable\">@i</span><span class=\"token operator\">+</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> {\n    <span class=\"token comment\">/* expressions */</span>\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@i</span> <span class=\"token keyword\">INT</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">WHILE</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">&lt;</span> <span class=\"token variable\">@length</span> <span class=\"token keyword\">BEGIN</span>\n\n    <span class=\"token comment\">/* expressions */</span>\n\n    <span class=\"token keyword\">SET</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">END</span></code></pre></div>\n<h3>C# style foreach</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">foreach<span class=\"token punctuation\">(</span>var <span class=\"token variable\">@row</span> <span class=\"token operator\">in</span> users<span class=\"token punctuation\">)</span> {\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> <span class=\"token variable\">@row.id</span> <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">)</span> {\n        <span class=\"token keyword\">print</span> <span class=\"token string\">'{{row.first}} {{row.last}}'</span>\n    }\n\n    <span class=\"token comment\">/* expressions */</span>\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@id</span> <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@first</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@last</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">DECLARE</span> cursor_1 <span class=\"token keyword\">CURSOR</span> <span class=\"token keyword\">FOR</span>\n<span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">first</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">last</span>\n<span class=\"token keyword\">FROM</span> users\n\n<span class=\"token keyword\">OPEN</span> cursor_1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">FETCH</span> <span class=\"token keyword\">NEXT</span> <span class=\"token keyword\">FROM</span> cursor_1\n<span class=\"token keyword\">INTO</span> <span class=\"token variable\">@id</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@first</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@last</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">WHILE</span> @<span class=\"token variable\">@FETCH_STATUS</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token keyword\">IF</span> <span class=\"token operator\">NOT</span><span class=\"token punctuation\">(</span> <span class=\"token variable\">@id</span> <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">BEGIN</span>\n        <span class=\"token keyword\">PRINT</span> <span class=\"token variable\">@first</span> <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token variable\">@last</span>\n    <span class=\"token keyword\">END</span>\n\n    <span class=\"token comment\">/* expressions */</span>\n\n    <span class=\"token keyword\">FETCH</span> <span class=\"token keyword\">NEXT</span> <span class=\"token keyword\">FROM</span> cursor_1\n    <span class=\"token keyword\">INTO</span> <span class=\"token variable\">@id</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@first</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@last</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span>\n\n<span class=\"token keyword\">CLOSE</span> cursor_1<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">DEALLOCATE</span> cursor_1<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Note: might want to talk about how this promotes precedural flow in SQL which isn’t necessarily a good thing…</p>\n<h3>String interpolation</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@name</span> <span class=\"token operator\">=</span> <span class=\"token string\">'john doe'</span>\n\n<span class=\"token comment\">-- prints 'my name is john doe'</span>\n<span class=\"token keyword\">print</span> <span class=\"token string\">'my name is: {{name}}'</span></code></pre></div>\n<p>Note: we could adopt something different than this sort of “mustache-style” here. We might want to think more about this. This is also potentially the most obvious breach of being a “strict superset” of SQL.</p>\n<h3>Local scoping rules</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>  { <span class=\"token comment\">// new variable scope...</span>\n    var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">print</span> <span class=\"token variable\">@i</span> <span class=\"token comment\">// prints 2</span>\n}\n\n<span class=\"token keyword\">print</span> <span class=\"token variable\">@i</span> <span class=\"token comment\">// prints 1</span></code></pre></div>\n<p>this would compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@true</span> <span class=\"token keyword\">BIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@i</span> <span class=\"token keyword\">INT</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@i_two</span> <span class=\"token keyword\">INT</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">IF</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@true</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@true</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">BEGIN</span>\n    <span class=\"token keyword\">SET</span> <span class=\"token variable\">@i_two</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">PRINT</span> <span class=\"token variable\">@i_two</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">END</span>\n\n<span class=\"token keyword\">PRINT</span> <span class=\"token variable\">@i</span></code></pre></div>\n<p>you can also declare local scope by just writing code inside brackets:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">{\n    <span class=\"token comment\">-- in this scope, @i is an int</span>\n    var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n}\n{\n    <span class=\"token comment\">-- in this scope, @i is of type varchar</span>\n    var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span>\n}</code></pre></div>\n<h3>Ternary operator</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token variable\">@a</span> <span class=\"token operator\">></span> <span class=\"token variable\">@b</span> ? <span class=\"token string\">'123'</span> : <span class=\"token string\">'456'</span></code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">CASE</span> <span class=\"token keyword\">WHEN</span> <span class=\"token variable\">@a</span> <span class=\"token operator\">></span> <span class=\"token variable\">@b</span> <span class=\"token keyword\">THEN</span> <span class=\"token string\">'123'</span> <span class=\"token keyword\">ELSE</span> <span class=\"token string\">'456'</span> <span class=\"token keyword\">END</span></code></pre></div>\n<h3>Null coalescing operator</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> students\n<span class=\"token keyword\">select</span> name ?? <span class=\"token string\">'N/A'</span></code></pre></div>\n<p>compiles into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> ISNULL<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token string\">'N/A'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> students</code></pre></div>\n<h3>Boolean operators</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@a</span> <span class=\"token operator\">||</span> <span class=\"token variable\">@b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token variable\">@c</span><span class=\"token punctuation\">)</span> {\n    <span class=\"token comment\">/* expressions */</span>\n}</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@true</span> <span class=\"token keyword\">BIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@false</span> <span class=\"token keyword\">BIT</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">IF</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@a</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@true</span> <span class=\"token operator\">OR</span> <span class=\"token variable\">@b</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@true</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">AND</span> <span class=\"token variable\">@c</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@false</span> <span class=\"token punctuation\">)</span> <span class=\"token keyword\">BEGIN</span>\n    <span class=\"token comment\">/* expressions */</span>\n<span class=\"token keyword\">END</span></code></pre></div>\n<h3>Method notation on various datatypes</h3>\n<p>various datatypes would have various “methods” defined for them which simply compile into calls for the global method…</p>\n<p>for instance, everything would have a <code class=\"language-text\">.toString()</code> method…</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">;</span>\nvar <span class=\"token variable\">@s</span> <span class=\"token operator\">=</span> <span class=\"token string\">' AbcdEf '</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">datetime</span> <span class=\"token variable\">@d</span> <span class=\"token operator\">=</span> GETUTCDATE<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>Methods for <code class=\"language-text\">char</code>, <code class=\"language-text\">varchar</code>, <code class=\"language-text\">nchar</code>, and <code class=\"language-text\">nvarchar</code></h4>\n<ul>\n<li>trim()</li>\n<li>ltrim()</li>\n<li>rtrim()</li>\n<li>toLowerCase()</li>\n<li>toUpperCase()</li>\n<li>toTitleCase() - not sure this is possible/practical</li>\n<li>padLeft()</li>\n<li>padRight()</li>\n<li>pad()</li>\n<li>contains(string s)</li>\n<li>endsWith(string s)</li>\n<li>startsWith(string s)</li>\n<li>substring</li>\n<li>split(string seperator) - this would return a table… could be interesting</li>\n<li>toCharSet() - not sure if this is possible/practical, but could be a cool feature as well.</li>\n<li>indexOf()</li>\n</ul>\n<p>calling methods on variables would work pretty much how you would expect:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token variable\">@s.trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">LTRIM<span class=\"token punctuation\">(</span>RTRIM<span class=\"token punctuation\">(</span><span class=\"token variable\">@s</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>and so on…</p>\n<h4>Methods for <code class=\"language-text\">datetime</code> and <code class=\"language-text\">date</code></h4>\n<ul>\n<li>addDays(numerical d)</li>\n<li>addHours(numerical d)</li>\n<li>addMinutes(numerical d)</li>\n<li>addMilliseconds(numerical d)</li>\n<li>addMonths(numerical d)</li>\n<li>addSeconds(numerical d)</li>\n<li>addTicks(numerical d)</li>\n<li>addYears(numerical d)</li>\n<li>toOADate()</li>\n<li>toString(string format)</li>\n<li>subtract(datetime d) - need to think about this more… how is a timespan represented in SQL?</li>\n<li>add(datetime d)</li>\n<li>dayOfMonth()</li>\n<li>dayOfYear()</li>\n<li>dayOfWeek()</li>\n<li>hour()</li>\n<li>minute()</li>\n<li>millisecond()</li>\n<li>ticks()</li>\n<li>second()</li>\n<li>year()</li>\n<li>date()</li>\n</ul>\n<p>note: i’d like to think more about functionality that can be had around UTC time / local time conversion and such. Could be a big win for this language if implemented in a way that prevented people from doing bad practices…</p>\n<h4>Methods on <code class=\"language-text\">int</code>, <code class=\"language-text\">bigint</code>, <code class=\"language-text\">tinyint</code>, <code class=\"language-text\">decimal</code>, <code class=\"language-text\">float</code></h4>\n<ul>\n<li>toString(string format)</li>\n</ul>\n<h3>Datetime declaration</h3>\n<p>a convention for declaring date times will exist, but i’m not sure on the syntax.</p>\n<p>could be: <code class=\"language-text\">var @dt = #1/12/2014#</code> (this is kind of similar to an MS Access convention).</p>\n<p>could also be <code class=\"language-text\">var @dt = &amp;&#39;1/12/2014&#39;</code></p>\n<h3>Regular expressions</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@a</span> <span class=\"token operator\">=</span> <span class=\"token operator\">/</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">|</span>o<span class=\"token punctuation\">)</span>me?reg<span class=\"token punctuation\">[</span>ular<span class=\"token punctuation\">]</span>ex<span class=\"token punctuation\">[</span>pression<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abcd'</span><span class=\"token punctuation\">,</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nvar <span class=\"token variable\">@islower</span> <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token operator\">/</span><span class=\"token punctuation\">[</span>A<span class=\"token operator\">-</span>Z<span class=\"token punctuation\">]</span><span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">match</span><span class=\"token punctuation\">(</span><span class=\"token variable\">@test</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Note: I’d like to do more thinking here on how we could bring more native support to regular expressions to SQL. This will largely depend on the target (ie, T-SQL, PL/SQL, etc.)</p>\n<h3>Explicit type casting</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">varchar</span><span class=\"token punctuation\">)</span><span class=\"token number\">123</span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> CAST<span class=\"token punctuation\">(</span><span class=\"token number\">123</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3><code class=\"language-text\">+=</code> and <code class=\"language-text\">-=</code> operators</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    <span class=\"token variable\">@s</span> <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token variable\">@i</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token variable\">@s</span> <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">'def'</span></code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@i</span> <span class=\"token keyword\">INT</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n        <span class=\"token variable\">@s</span> <span class=\"token keyword\">varchar</span> <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SET</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@i</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SET</span> <span class=\"token variable\">@s</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@s</span> <span class=\"token operator\">+</span> <span class=\"token string\">'def'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Paging syntax</h3>\n<p>The <code class=\"language-text\">offset</code> and <code class=\"language-text\">limit</code> keywords will be used for paging, and will\nsatisfy all SQL targets appropriately.</p>\n<p>For instance:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> tbl\n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> a\n<span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c\n<span class=\"token keyword\">offset</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">limit</span> <span class=\"token number\">20</span></code></pre></div>\n<p>for SQL Server 2008 would compile into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token punctuation\">;</span><span class=\"token keyword\">WITH</span> tbl_paged <span class=\"token keyword\">AS</span>\n<span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">SELECT</span>\n        a<span class=\"token punctuation\">,</span>\n        b<span class=\"token punctuation\">,</span>\n        c<span class=\"token punctuation\">,</span>\n        ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> a <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> __row_number\n    <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> tbl_paged\n<span class=\"token keyword\">WHERE</span> __row_number <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">100</span> <span class=\"token operator\">AND</span> <span class=\"token number\">100</span> <span class=\"token operator\">+</span> <span class=\"token number\">20</span></code></pre></div>\n<p>Versus MySQL where it would simply compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> tbl\n<span class=\"token keyword\">OFFSET</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">20</span></code></pre></div>\n<p>Of course, we are also able to use variables or scalar expressions here</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">from</span> tbl\n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span> a\n<span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c\n<span class=\"token keyword\">offset</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@page</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token variable\">@size</span>\n<span class=\"token keyword\">limit</span> <span class=\"token variable\">@size</span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token punctuation\">;</span><span class=\"token keyword\">WITH</span> tbl_paged <span class=\"token keyword\">AS</span>\n<span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">SELECT</span>\n        a<span class=\"token punctuation\">,</span>\n        b<span class=\"token punctuation\">,</span>\n        c<span class=\"token punctuation\">,</span>\n        ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> a <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> __row_number\n    <span class=\"token keyword\">FROM</span> tbl\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> tbl_paged\n<span class=\"token keyword\">WHERE</span> __row_number <span class=\"token operator\">BETWEEN</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@page</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token variable\">@size</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">AND</span> <span class=\"token variable\">@page</span> <span class=\"token operator\">*</span> <span class=\"token variable\">@size</span></code></pre></div>\n<p>NOTE: the compilation of these keywords would be different depending on the target… different SQL engines have different support for paging already.</p>\n<h3>Implicit “result sets” as local variables</h3>\n<p>Result set variables can be declared as you would any other query select statement</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@results</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> tbl1 <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token keyword\">where</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Result set variables have a couple of unique properties that temp tables and table variables do not have…</p>\n<p>For example, you can…</p>\n<h4>Coerce a resultset variable into a boolean as a shortcut for <code class=\"language-text\">EXISTS</code></h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@results</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> tbl1 <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token keyword\">where</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token variable\">@results</span><span class=\"token punctuation\">)</span> {\n    <span class=\"token comment\">/* expressions */</span>\n}</code></pre></div>\n<p>this will compile into:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@results</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">(</span>\n            a <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n            b <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            c <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token variable\">@results</span> <span class=\"token punctuation\">(</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> tbl1\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span>\n\n<span class=\"token keyword\">IF</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">TOP</span> <span class=\"token number\">1</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token variable\">@results</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">BEGIN</span>\n    <span class=\"token comment\">/* expressions */</span>\n<span class=\"token keyword\">END</span></code></pre></div>\n<h4>Get a resultset variable’s number of rows</h4>\n<p>calling a <code class=\"language-text\">.length</code> method on a resultset variable is shorthand for getting the total count</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@results</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> tbl1 <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token keyword\">where</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\nvar <span class=\"token variable\">@count</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@results.length</span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@results</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">(</span>\n            a <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n            b <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            c <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">DECLARE</span> <span class=\"token variable\">@count</span> <span class=\"token keyword\">INT</span>\n\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token variable\">@results</span> <span class=\"token punctuation\">(</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> tbl1\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span>\n\n<span class=\"token keyword\">SELECT</span> <span class=\"token variable\">@count</span> <span class=\"token operator\">=</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token variable\">@results</span></code></pre></div>\n<p>in certain cases where a resultset variable can be optimized into a CTE, it will do so. This is the case when the query is referenced in only one statement.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@results</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> tbl1 <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token keyword\">where</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- here we only use results in *one* statement</span>\n<span class=\"token keyword\">from</span> <span class=\"token variable\">@results</span>\n<span class=\"token keyword\">where</span> a <span class=\"token operator\">></span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token punctuation\">;</span><span class=\"token keyword\">WITH</span> results <span class=\"token keyword\">AS</span>\n<span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">SELECT</span>\n        a<span class=\"token punctuation\">,</span>\n        b<span class=\"token punctuation\">,</span>\n        c\n    <span class=\"token keyword\">FROM</span> tbl1\n    <span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> results\n<span class=\"token keyword\">WHERE</span> a <span class=\"token operator\">></span> <span class=\"token number\">10</span></code></pre></div>\n<p>note: some of the above examples would also allow and utilize this optimization, but the compiled output shown is that of the more general case (table variables) simply for clarity of what would normally happen.</p>\n<p>In other cases, the resultset variable will be created as a table variable</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@results</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> tbl1 <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c <span class=\"token keyword\">where</span> a <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n\nvar <span class=\"token variable\">@count</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@results.length</span></code></pre></div>\n<h3>Resultsets as partial queries</h3>\n<p>Resultset variables can be useful in taking complex queries and compartmentalizing them into digestable parts without sacrificing performance by storing the results into temp tables, or going through the unnecessary overhead of creating a view to be used just once:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- notice how no \"select\" clause is needed here...</span>\nvar <span class=\"token variable\">@unpaid_cust</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">from</span> customers <span class=\"token keyword\">where</span> <span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'unpaid'</span>\n\n<span class=\"token keyword\">from</span> invoices i\n<span class=\"token keyword\">inner</span> <span class=\"token keyword\">join</span> <span class=\"token variable\">@unpaid_cust</span>\n<span class=\"token keyword\">where</span> i<span class=\"token punctuation\">.</span>date_sent <span class=\"token operator\">!=</span> <span class=\"token boolean\">null</span>\n<span class=\"token keyword\">select</span> invoices<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span>$<span class=\"token keyword\">all</span><span class=\"token operator\">></span></code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    i<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n    i<span class=\"token punctuation\">.</span>field1<span class=\"token punctuation\">,</span>\n    <span class=\"token comment\">/* ... */</span>\n<span class=\"token keyword\">FROM</span> invoices i\n<span class=\"token keyword\">INNER</span> <span class=\"token keyword\">JOIN</span> customers c\n<span class=\"token keyword\">ON</span> i<span class=\"token punctuation\">.</span>customer_id <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">WHERE</span>\n    c<span class=\"token punctuation\">.</span><span class=\"token keyword\">status</span> <span class=\"token operator\">=</span> <span class=\"token string\">'unpaid'</span> <span class=\"token operator\">AND</span>\n    i<span class=\"token punctuation\">.</span>date_sent <span class=\"token operator\">IS</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span></code></pre></div>\n<p>Although this is a smple example, it should be clear how you can take a very complex query with several joins and partialize it into logically separate pieces, letting BQL compile it into one final efficient query.</p>\n<h3>Mixins: Inline Functions</h3>\n<p>simple inline functions:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@postUrl</span> <span class=\"token operator\">=</span> mixin<span class=\"token punctuation\">(</span><span class=\"token variable\">@id</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">@slug</span><span class=\"token punctuation\">)</span> {\n    <span class=\"token keyword\">return</span> <span class=\"token string\">'http://my-blog.com/post/{{@id}}/{{slug}}'</span>\n}\n\n\n<span class=\"token keyword\">from</span> post\n<span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> <span class=\"token variable\">@postUrl</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">,</span>slug<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> url</code></pre></div>\n<p>compiles into</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    id<span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'http://my-blog.com/post/'</span> <span class=\"token operator\">+</span> CAST<span class=\"token punctuation\">(</span>id <span class=\"token keyword\">as</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">'/'</span> <span class=\"token operator\">+</span> slug\n<span class=\"token keyword\">FROM</span> posts</code></pre></div>\n<p>or…</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">var <span class=\"token variable\">@isEmail</span> <span class=\"token operator\">=</span> mixin<span class=\"token punctuation\">(</span><span class=\"token variable\">@email</span><span class=\"token punctuation\">)</span>{\n    <span class=\"token keyword\">return</span> <span class=\"token variable\">@email.contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">)</span>\n}\n\n<span class=\"token keyword\">from</span> users\n<span class=\"token keyword\">where</span> <span class=\"token variable\">@isEmail</span><span class=\"token punctuation\">(</span>email<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">select</span> id<span class=\"token punctuation\">,</span> email</code></pre></div>\n<p>compiles to</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> id<span class=\"token punctuation\">,</span> email\n<span class=\"token keyword\">FROM</span> users\n<span class=\"token keyword\">WHERE</span> CHARINDEX<span class=\"token punctuation\">(</span><span class=\"token string\">'@'</span><span class=\"token punctuation\">,</span>email<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span></code></pre></div>\n<h3>Schema scope declaration</h3>\n<p>you can use a schema scope declaration in order to default to certain databases and schema</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">    <span class=\"token keyword\">schema</span> abc {\n        <span class=\"token keyword\">from</span> tbl1\n        <span class=\"token keyword\">select</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c\n    }</code></pre></div>\n<p>compiles to:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c\n<span class=\"token keyword\">FROM</span> abc<span class=\"token punctuation\">.</span>tbl1</code></pre></div>\n<p>if no schema scope is used, the schema will instead be the database default schema. This is essentially like locally “overriding” the database default schema…</p>\n<h3>Some ideas I haven’t thought through yet…</h3>\n<ol>\n<li>\n<p>support for more complicated aggregate functions? For example a <code class=\"language-text\">JOIN</code> or <code class=\"language-text\">CSV</code> aggregate function based on the XML expand functionality.</p>\n</li>\n<li>\n<p>what about boolean logic w/ nulls? could we allow <code class=\"language-text\">if (field_name = null)</code> in replacement of <code class=\"language-text\">IF (field_name IS NULL)</code>?</p>\n</li>\n<li>\n<p>We could have some javascript-like type coersion? For example, could <code class=\"language-text\">!field_name</code> be converted to <code class=\"language-text\">field_name is null OR field_name = &#39;&#39;</code> and similar tests?</p>\n</li>\n</ol>\n<h3>Next steps…</h3>\n<p>Languages are complicated things, and I think in order to be successful, must be the product of many minds. I’d like for any and all feedback (or help) on producing this language spec, as well as a parser/compiler for it. If you stumbles upon this article because you have similar wishes for such a language to exist, please consider contributing.</p>\n<p>I’ve opened a <a href=\"https://github.com/lelandrichardson/BQL\">GitHub repo</a> where I’ve started work on the parser and grammar. Right now I’m trying out <a href=\"http://irony.codeplex.com/\">Irony</a> to build an AST, as it makes building into the Visual Studio toolchain very easy, but the Irony grammar is very easy to translate into BNF if we want to try other AST Parsers as well.</p>\n<p><strong>At the very least, share your opinions below.</strong></p>\n<p>Thank you.</p>","fields":{"readingTime":{"text":"20 min read"}},"frontmatter":{"title":"A Better Query Language: BQL Language Specification","date":"March 05, 2014"}}},"pageContext":{"slug":"/a-better-query-language-bql-language-specification/","previous":{"fields":{"slug":"/handling-paged-datasets-in-knockoutjs/"},"frontmatter":{"title":"Handling Paged Datasets in Knockout.js"}},"next":{"fields":{"slug":"/creating-a-dictionary-which-doesnt-throw-a-keynotfoundexception/"},"frontmatter":{"title":"Creating a Dictionary<T,V> which doesn't throw a KeyNotFoundException"}}}}