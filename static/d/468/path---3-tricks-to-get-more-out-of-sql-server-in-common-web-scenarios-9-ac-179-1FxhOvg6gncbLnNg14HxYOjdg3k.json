{
  "data": {
    "site": {
      "siteMetadata": {
        "title": "Intelligible Babble",
        "author": "Leland Richardson"
      }
    },
    "markdownRemark": {
      "id": "cd4fd423-880a-5a1a-8c86-b5a29e696baa",
      "excerpt": "Learn several little-known SQL tricks/techniques used to improve query times and enforce business rules with common everyday web-development…",
      "html": "<p>Learn several little-known SQL tricks/techniques used to improve query times and enforce business rules with common everyday web-development scenarios</p>\n<h3>Article Index:</h3>\n<ul>\n<li>The MERGE Statement</li>\n<li>Indexed Views (a.k.a Materialized Views)</li>\n<li>Common Table Expressions</li>\n</ul>\n<h2>1. The MERGE Statement</h2>\n<p>The <a href=\"http://msdn.microsoft.com/en-us/library/bb510625.aspx\">Merge Statement</a> is a small treasure made available in SQL Server 2008.  It can be used in many different scenarios, but I find it constantly useful in simplifying some CRUD-type logic in Web Apps.</p>\n<p>Fundamentally, the MERGE Statement takes two tables, one being the <strong>SOURCE</strong> table and the other being the <strong>TARGET</strong> table, and attempts to perform a join based on some criteria.  In most cases this will be a common identity or key column just as it would be in a normal SQL JOIN.  Using these two tables, it allows you to specify several different actions to perform for different scenarios.  The canonical use of this, which may be clear from the name of the statement, is to take two tables which hold essentially the same information, and MERGE them together.</p>\n<p>Let’s say you have a member table defined like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE TABLE [dbo].[Member](\n\t[ID] int,\n\t[Email] varchar(127),\n\t[FullName] varchar(127),\n\t[IsSubscribed] bit\n)</code></pre></div>\n<p>Additionally, you might have a separate table called “Subscriber” which holds a subscriber email list for your product.  Now, traditionally it would make more sense for you to just have one table, since we have both an email field and an “IsSubscribed” flag to indicate that they should get your email, but your subscriber table might be from some third party tool and so you might need to perform some synchronization.  This is exactly the scenario MERGE was intended for.</p>\n<p>So with our Subscriber table which might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE TABLE [dbo].[Subscriber](\n\t[Email] varchar(127),\n\t[FullName] varchar(127),\n\t[DateSubscribed] datetime\n)</code></pre></div>\n<p>We can now synchronize these two tables using MERGE:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MERGE dbo.Member as TARGET\nUSING dbo.Subscriber as SOURCE\nON ( TARGET.Email = SOURCE.Email )\nWHEN MATCHED THEN\n\t-- SOURCE has matching email in TARGET\n\t-- UPDATE TARGET to indicate its a subscriber\n\tUPDATE SET TARGET.[IsSubscribed] = ((1))\n\t\nWHEN NOT MATCHED BY TARGET THEN\n\t-- SOURCE has row with no match in TARGET\n\t-- INSERT missing subscriber into TARGET\n\tINSERT (Email, FullName, IsSubscribed)\n\tVALUES (SOURCE.Email, SOURCE.FullName, ((1)));</code></pre></div>\n<p>These are often called “Delta Operations” when you are trying to determine the differences on two tables based off some common key.</p>\n<h3>Enforce voting system business logic efficiently with MERGE</h3>\n<p>This is great, but truth be told this scenario doesn’t come up ALL that often.  I end up using the MERGE statement in a bit of a different way so let me walk you through how it has been useful for me:</p>\n<p>Let’s say you have a web application where a heavy amount of voting is performed on some entity.  You have the following business rules:</p>\n<ul>\n<li>an Entity can be voted up or down with amount +1 or -1</li>\n<li>a user is allowed to cast one vote per entity</li>\n</ul>\n<p>Given we have the two tables:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE TABLE [dbo].[Entity](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t-- More Entity specific fields\t\n)\n\nCREATE TABLE [dbo].[EntityVote](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[VoterId] [int] NOT NULL,\n\t[EntityId] [int] NOT NULL,\n\t[Direction] [int] NOT NULL\n)</code></pre></div>\n<p>You would like to have a web page with some up-vote and down-vote button which votes via AJAX.</p>\n<p>Well, you want to make sure that your business rules are enforced at the database level (or at least server-side) so that user’s can’t register false votes for a given entity (each user can only vote once!)</p>\n<p>One quick approach which is sure to work is to create a UNIQUE INDEX on the EntityVote table</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE UNIQUE NONCLUSTERED INDEX [IX_Entity_Vote_SingleVote] \nON [dbo].[EntityVote] \n(\n\t[EntityId] ASC,\n\t[VoterId] ASC\n)</code></pre></div>\n<p>This will enforce your business rules, and prevent users from “hacking” the system.  This is less than ideal, however, as every time a user tries to insert a vote again this will raise an error on SQL Server and will cause unnecessary overhead since it is not being handled.</p>\n<p>In order to circumvent this, you may then decide to build a more robust Stored Procedure to handle this logic when working with a vote.  Us developers may want to write this stored procedure like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE PROCEDURE [dbo].[spu_Entity_Vote_Insert](\n\t@VoterId int,\n\t@EntityId int,\n\t@Direction int\n)\nAS\nBEGIN\n\tSET NOCOUNT ON;\n\t\n\t\n\tIF EXISTS(\n\t\tSELECT TOP 1 \n\t\t\tId \n\t\tFROM dbo.EntityVote \n\t\tWHERE VoterId = @VoterId\n\t\tAND EntityId = @EntityId\n\t\tAND Direction = @Direction)\n\tBEGIN\n\t\t--same vote exists -&gt; user is &quot;un-voting&quot;\n\t\tDELETE FROM dbo.EntityVote\n\t\tWHERE VoterId = @VoterId\n\t\tAND EntityId = @EntityId\n\t\tAND Direction = @Direction\n\tEND\n\tELSE IF EXISTS(\n\t\tSELECT TOP 1 \n\t\t\tId \n\t\tFROM dbo.EntityVote \n\t\tWHERE VoterId = @VoterId\n\t\tAND EntityId = @EntityId\n\t\tAND Direction &lt;&gt; @Direction)\n\tBEGIN\n\t\t--same voter/entity exists, but different amount\n\t\t--this means user is changing his mind.\n\t\tUPDATE dbo.EntityVote \n\t\t\tSET Direction = @Direction\n\t\tWHERE VoterId = @VoterId\n\t\tAND EntityId = @EntityId\n\t\tAND Direction &lt;&gt; @Direction\n\tEND\n\tELSE\n\tBEGIN\n\t\t--new voter/entity combo, insert vote\n\t\tINSERT INTO dbo.EntityVote(\n\t\t\tVoterId, \n\t\t\tEntityId, \n\t\t\tDirection\n\t\t) VALUES (\n\t\t\t@VoterId, \n\t\t\t@EntityId, \n\t\t\t@Direction\n\t\t)\n\tEND\nEND</code></pre></div>\n<h3>Avoid Race Conditions in “UPSERT”</h3>\n<p>What the DBA’s reading this might be thinking after looking at a stored procedure like that is that you have just introduced a <a href=\"http://weblogs.sqlteam.com/dang/archive/2007/10/28/Conditional-INSERTUPDATE-Race-Condition.aspx\">Race Condition</a>.</p>\n<p>Race Conditions stem from the fact that us simple-minded developers often times write SQL (and code in general) under the false assumption that this code is only ever going to be run synchronously, and that these IF/ELSE Logic loops will always return the same result within the context of the procedure.  Since SQL Server can hold MANY connections at once, any of which can be executing this stored procedure, we could have a situation where this is not true.</p>\n<p>For those of you who are MySQL devs, you might be familiar with the INSERT .. ON DUPLICATE KEY UPDATE … syntax, which I was always jealous of after moving to SQL Server (this was before I knew about the MERGE syntax…).</p>\n<p>In any event, one way to prevent this, as mentioned in the article above, is to simply demand that all of this be executed as a single transaction.  This can be done with the <strong>BEGIN TRAN</strong> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE PROCEDURE [dbo].[spu_Entity_Vote_Insert](\n\t@VoterId int,\n\t@EntityId int,\n\t@Direction int\n)\nAS\nBEGIN\n\tSET NOCOUNT, XACT_ABORT ON\n \n\tBEGIN TRAN\n\t\n\t-- original stored procedure code\n\t\n\tCOMMIT\nEND</code></pre></div>\n<p>I don’t know about you guys, but this starts to worry me a little bit. Seems like there is a lot going on there for one transaction, and I don’t like to use the BEGIN TRAN / COMMIT statements loosely.  Here is where the MERGE statement can help us.  The MERGE statement is actually built for all of this “UPSERT” type madness and is run off of a a single join + scan, and thus a single transaction:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE PROCEDURE [dbo].[spu_Entity_Vote_Insert](\n\t@VoterId int,\n\t@EntityId int,\n\t@Direction int\n)\nAS\nBEGIN\n\tSET NOCOUNT ON;\n\t\n\tMERGE dbo.EntityVote as TARGET\n\tUSING ( SELECT \n\t\t@VoterId as VoterId, \n\t\t@EntityId as EntityId, \n\t\t@Direction as Direction\n\t) as SOURCE \n\tON (\n\t\tSOURCE.EntityId = TARGET.EntityId \n\t\tAND \n\t\tSOURCE.VoterId = TARGET.VoterId\n\t)\n\t--same vote exists -&gt; user is &quot;un-voting&quot;\n\tWHEN MATCHED AND (SOURCE.Direction = TARGET.Direction)\n\t\tTHEN DELETE \n\t\n\t--same voter/entity exists, but different amount\n\t--this means user is changing his mind.\n\tWHEN MATCHED AND (SOURCE.Direction &lt;&gt; TARGET.Direction) \n\t\tTHEN UPDATE \n\t\t\tSET TARGET.Direction = SOURCE.Direction\n\t\t\n\t--new voter/entity combo, insert vote\n\tWHEN NOT MATCHED\n\t\tTHEN INSERT (\n\t\t\tVoterId, \n\t\t\tEntityId, \n\t\t\tDirection\n\t\t) VALUES (\n\t\t\tSOURCE.VoterId, \n\t\t\tSOURCE.EntityId, \n\t\t\tSOURCE.Direction\n\t\t)\n\t;\nEND</code></pre></div>\n<p>This statement will find out if the record exists, and then operate on it appropriately - allowing us to expand the logic if necessary.  While at first this may be slightly less readable, once you get familiar with the syntax it is actually much better in my opinion.  Plus, we don’t have to get into any of that nasty BEGIN TRAN / COMMIT stuff.</p>\n<p><br/><br/></p>\n<h2>2. Indexed Views (a.k.a Materialized Views)</h2>\n<p>As far as I am aware, there is no MySQL equivalent to the SQL Server Indexed Views.  While most developer-facing differences between the two database engines comes down to semantics, I actually consider this to be a fairly large win for MS SQL.  While they can certainly be overused, if you have relationships across large tables that are being utilized on a regular basis in the form of a READ, and the tables are not too INSERT heavy, <strong>indexed views can be a tremendous win.</strong></p>\n<p>This came in quite handy for me a couple of weeks ago in a situation which I think is quite common: a web application where some Entity has comments.  Comments are usually associated with an application User, which is also another table.  So that makes an Entity table, Comments table, and User (“Member”) table:<sup>1</sup></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE TABLE [dbo].[Entity](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t-- More Entity specific fields\t\n)\n\nCREATE TABLE [dbo].[Member](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[FullName] varchar(50) NOT NULL,\n\t-- More member-related specific fields\t\n)\n\nCREATE TABLE [dbo].[EntityComment](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[MemberId] [int] NOT NULL,\n\t[EntityId] [int] NOT NULL,\n\t[CommentBody] varchar(MAX) NOT NULL,\n\t[DateCreated] datetime NOT NULL\n)</code></pre></div>\n<p>Actually, wait.  Let’s make it even better.  Let’s say we have multiple entities, each of which have comments…  so being the nice relational DBA’s that we are, we decide that ALL comments for ALL entities will reside in one table, and we will just create a Cross Reference table for each entity.  So now we have this…</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE TABLE [dbo].[Entity](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t-- More Entity specific fields\t\n)\n\nCREATE TABLE [dbo].[Member](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[FullName] varchar(50) NOT NULL,\n\t-- More member-related specific fields\t\n)\n\nCREATE TABLE [dbo].[EntityToComment](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[CommentId] [int] NOT NULL,\n\t[EntityId] [int] NOT NULL\n)\n\nCREATE TABLE [dbo].[Comment](\n\t[Id] [int] IDENTITY(1,1) NOT NULL,\n\t[MemberId] [int] NOT NULL,\n\t[CommentBody] varchar(MAX) NOT NULL,\n\t[DateCreated] datetime NOT NULL\n)</code></pre></div>\n<p>Now, in a typical scenario we might have a web-page which is viewing an Entity based off of the primary key…  ie, some endpoint like:  <strong>www.example.com/entity/detail/123</strong></p>\n<p>Naturally, here we write a nice little query to pull all of the data for the entity with a simple primary key lookup:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *\nFROM dbo.Entity\nWHERE Id = @Id</code></pre></div>\n<p>Done.  Now we want the comments…  and things get a little bit messier.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT\n\tc.*,\n\tm.*\nFROM dbo.EntityToComment as ec\nINNER JOIN dbo.Comment as c\nON c.Id = ec.CommentId\nINNER JOIN dbo.Member as m\nON m.Id = c.MemberId\nWHERE ec.EntityId = @Id</code></pre></div>\n<p>OK. Great.  Looks like we are done!  We now have all of the information we need to display comments on the client.</p>\n<p>While this is true, let’s say your site makes it big and your Comments table all of a sudden gets to be a couple of million rows long.  More than that, maybe your member table and entity tables are similarly of <code class=\"language-text\">O(10^6)</code>.  <strong>For a high traffic site, this is not going to cut it.</strong></p>\n<p>The first thing you would want to do is to create an index on dbo.Comment over the MemberId column.  Similarly, you could create an index across the dbo.EntityToComment for the EntityId, CommentId columns.  This will definitely be faster, but you know what can be EVEN FASTER?  <strong>Indexed views</strong>.  In order to use indexed views one first must create a Schema Bound view like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE VIEW [dbo].[vu_Entity_Comment_Member]\nWITH SCHEMABINDING \nAS\nSELECT\n\tc.Id,\n\tc.CommentBody,\n\tc.DateCreated,\n\tc.MemberId,\n\tm.FullName,\n\t-- more Comment or Member fields, if needed\nFROM dbo.EntityToComment as ec\nINNER JOIN dbo.Comment as c\nON c.Id = ec.CommentId\nINNER JOIN dbo.Member as m\nON m.Id = c.MemberId</code></pre></div>\n<p>Notice the <strong>WITH SCHEMABINDING</strong> keyword here. This is important, and SQL Server will yell at you if you try to create an index on a table which is not Schema Bound.  This essentially means that the <a href=\"http://msdn.microsoft.com/en-us/library/ms187956.aspx\">view has constraints such that the referenced tables can not be altered in a way that would make the view invalid</a>.  If you ask me, this should be a default value for SQL Views - but that’s another discussion.  In any event, <strong>if you use views in SQL Server, it wouldn’t be a bad idea to use the SCHEMABINDING keyword all of the time.</strong></p>\n<p>Now we actually want to create a non-clustered index on the view in question.  A lot of people find indexes to be these mystical creatures that can never be tamed or tricked into showing up in our execution plans, but BTREE-like indexes AREN’T THAT HARD to understand if you <a href=\"http://en.wikipedia.org/wiki/B-tree\">sit down and actually think about what they are</a> and <a href=\"http://msdn.microsoft.com/en-us/library/aa174537%28v=sql.80%29.aspx\">how they work</a>.  For now I will take the easy route out and say that is outside the scope of this post, but I strongly encourage reading the links above if you don’t think you could explain an index to a 10 year old…  your users will thank you.<sup>2</sup></p>\n<p>The index we want on our view is one which has EntityId’s as primary nodes, since that is what we will be passing in the WHERE clause in our web page’s stored procedure.  The EntityId is not unique on this view (ie, there will be multiple rows returned per EntityId) and thus we will need to create a UNIQUE index first, then the Non-clustered index: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CREATE UNIQUE CLUSTERED INDEX [IX_vu_Entity_Comment_Member_Unique] \nON [dbo].[vu_Entity_Comment_Member] \n([ID] ASC)\n\nCREATE NONCLUSTERED INDEX IX_EntityId_vu_Question_Comment_Member\nON [dbo].[vu_Entity_Comment_Member] (EntityId)\nINCLUDE (Id,\n\tCommentBody,\n\tDateCreated,\n\tMemberId,\n\tFullName,\n\t-- more columns from the view, if needed\n)</code></pre></div>\n<p>It is important to note that in the Non-Clustered view you will want to INCLUDE every row that you need to push onto the Client through our stored procedure.  By including all of these columns, SQL Server is able to avoid a Table Scan in the query, and simply pull the page out of the in-memory index.  <strong>This is where our performance gain is</strong>.  Our previous 2 inner joins which required a ton of computation have essentially been reduced to a single memory lookup operation that will complete in unit time!</p>\n<p>So we go back to our stored procedure for our Entity’s detail view with comments and we rewrite our query to use the view instead of the joins:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT \n\tId,\n\tCommentBody,\n\tDateCreated,\n\tMemberId,\n\tFullName,\n\t-- more columns, if needed\nFROM [dbo].[vu_Entity_Comment_Member]\nWITH (NOEXPAND)\nWHERE EntityId = @Id</code></pre></div>\n<p>It’s important to notice the query hint <strong>WITH (NOEXPAND)</strong> added.  As far as I know, this simply tells SQL Server that you would like it to treat the view as a TABLE, and not to scan the underlying tables if it doesn’t need to.  You can <a href=\"http://sladescross.wordpress.com/2010/09/26/sql-noexpand-and-indexed-views/\">find out more about NOEXPAND and Indexed Views here</a>.</p>\n<p>At this point, this stored procedure will be blazing fast, <strong>even with millions and millions of rows in the corresponding tables</strong>.  I chose this example as I think it is a fairly common web-based scenario, as the title suggests, but any developer working in SQL should think about indexed views when constantly hitting tables with multiple joins.<sup>3</sup>  Table Indexes are tremendously helpful for searching across single tables from non-primary keys, but Indexed views can essentially give us the speed of denormalization without needing to worry about synchronizing the denormalized and normalized data.</p>\n<p>Long story short, <strong>page load times are important, and Indexed Views can be a valuable tool to improve them</strong>.  You can see a <a href=\"http://samsaffron.com/archive/2011/05/02/A+day+in+the+life+of+a+slow+page+at+Stack+Overflow\">similar use of indexes to improve page performance of stack overflow over at Sam Saffron’s blog</a>.</p>\n<p><br/><br/></p>\n<h2>3. Common Table Expressions</h2>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/ms190766%28v=sql.105%29.aspx\">Common Table Expressions</a> are another example of a great tool that I discovered moving from MySQL to SQL Server.  As far as I know, you can’t do quite everything you can do with CTE in MySQL (but I welcome someone to show me that this is incorrect)<sup>4</sup>.</p>\n<p>Anyway, CTE is essentially a way to reduce the complexity of complex queries by aliasing them.  Here is a simple use case:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WITH CustomerPurchase(\n\tProductId, \n\tCustomerId, \n\tCustomerName, \n\tAmount\n) AS (\n\tSELECT\n\t\tp.Id,\n\t\tc.Id,\n\t\tc.CustomerName,\n\t\tp.Amount\n\tFROM Purchase as p\n\tINNER JOIN Customer as c\n\tON p.CustomerId = c.Id\n)\nSELECT *\nFROM CustomerPurchase\nWHERE ProductId = @ProductId</code></pre></div>\n<p>This is cool, but doesn’t really help us all that much outside readability and maintainability (and in this case doesn’t even do much there…  but I promise, sometimes it is more readable/maintainable)</p>\n<h3>Use Common Table Expressions to implement Paging</h3>\n<p>On the other hand, CTE allows us to define calculated columns in our table and then filter them later, which provides us a bigger win.  In the case of SQL Server’s built-in RANK functions, this is actually not possible to do without the use of a sub-query.  <strong>For example, we can implement PAGING on a table very easily like so</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WITH Activity  AS\n(\n\tSELECT [ID]\n\t  -- more columns related to Entity\n\t  ,[LastActivityDate]\n\t  ,ROW_NUMBER() OVER \n                (ORDER BY [LastActivityDate] DESC) AS RowNumber\n\tFROM [dbo].[Entity]\n)\nSELECT *\nFROM Activity\nWHERE RowNumber \n      BETWEEN (@pageNumber - 1) * @perPage + 1 \n      AND @pageNumber * @perPage\nORDER BY RowNumber ASC;</code></pre></div>\n<p>Paging is incredibly important in web-development and should be implemented whenever possible to reduce the number of bytes sent across the wire that are never even seen.  Implementing Paging this way should be properly fast provided whatever you have in your OVER() clause is properly indexed.</p>\n<p>This is honestly the most valuable thing I have found for Common Table Expressions other than improving readability, but there are some additional compelling uses in the <a href=\"http://www.codeproject.com/Articles/83654/Inside-Recursive-CTEs\">ability to use CTEs recursively</a></p>\n<h3>Author’s Note:</h3>\n<p>SQL is one of those things that I just tend to learn new things about constantly.  While I consider myself a fairly competent SQL developer, I am by no means a DBA.  I am sure in a years time I will know much more than I know now, just as now I know far more than I did a year ago, today.  This article is meant to educate those who do not know of these features as I did not at one time.  Additionally, <strong>please let me know if you found the article useful</strong>!</p>\n<p>P.S.:  If you are one of the few I’ve promised to do a followup post on my <a href=\"http://www.intelligiblebabble.com/how-jquery-and-unobtrusive-javascript-can-be-poisonous/\" target=\"_blank\">jQuery poor practices</a> article from last week,  I promise you it is coming - this one just got done first.</p>\n<hr/>\n###Footnotes:###\n<ol>\n<li>\n<p>if those links don’t help you, and you are still wanting to learn more, send me an email or a comment and I can point you to some great free online courses discussing indexes in more detail.</p>\n</li>\n<li>\n<p>Potential Argument:  One might say that a comment table is not a good example of an entity which has few reads…  I would beg to differ.  In the world of the internet, almost EVERY entity will be a “high-read” entity, with the exception of a logging table where inserts will be proportional to the overall number of requests.</p>\n</li>\n<li>\n<p>Note: while this is great, one should also weigh the pros and cons between the decrease in read time and the increase in insert time.</p>\n</li>\n<li>\n<p>Note:  when I say “can’t do”, what I really mean is “can’t do without the use of temporary tables or sub-queries”</p>\n</li>\n</ol>",
      "fields": { "readingTime": { "text": "16 min read" } },
      "frontmatter": {
        "title": "3 Tricks to get More out of SQL Server in Common Web Scenarios",
        "date": "July 03, 2012"
      }
    }
  },
  "pageContext": {
    "slug": "/3-tricks-to-get-more-out-of-sql-server-in-common-web-scenarios/",
    "previous": {
      "fields": { "slug": "/hello-world/" },
      "frontmatter": { "title": "Lets look at some code" }
    },
    "next": {
      "fields": {
        "slug": "/a-better-query-language-bql-language-specification/"
      },
      "frontmatter": { "title": "Just text and links" }
    }
  }
}
